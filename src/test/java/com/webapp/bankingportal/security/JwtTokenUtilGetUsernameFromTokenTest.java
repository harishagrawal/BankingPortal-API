// ********RoostGPT********
/*
Test generated by RoostGPT for test bankingportal using AI Type DBRX and AI Model mixtral-8x7b-instruct-v0.1

ROOST_METHOD_HASH=getUsernameFromToken_ecb4cc4a64
ROOST_METHOD_SIG_HASH=getUsernameFromToken_a39e85e547

1. Scenario [1]: Verify valid JWT token with a valid subject claim

TestName: testValidTokenWithSubjectClaim()

Details:
This test checks whether the `getUsernameFromToken` method correctly extracts the subject claim from a valid JWT token.

Execution:
Arrange: Create a valid JWT token with a subject claim.

Act: Invoke the `getUsernameFromToken` method with the valid JWT token.

Assert: Use JUnit assertions to compare the actual subject claim with the expected subject claim.

Validation:
The assertion aims to verify that the method correctly extracts the subject claim from a valid JWT token. This test is significant because it checks the basic functionality of the method when provided with a valid token.

1. Scenario [2]: Verify JWT token with an expired expiration time

TestName: testExpiredTokenExpirationTime()

Details:
This test checks whether the `getUsernameFromToken` method correctly handles JWT tokens with expired expiration times.

Execution:
Arrange: Create a JWT token with an expired expiration time.

Act: Invoke the `getUsernameFromToken` method with the expired JWT token.

Assert: Use JUnit assertions to check if the method throws an appropriate exception, or the expected behavior when handling expired tokens.

Validation:
The assertion aims to verify that the method handles expired JWT tokens as expected, ensuring proper error handling and security measures.

1. Scenario [3]: Verify JWT token with an invalid signature

TestName: testInvalidTokenSignature()

Details:
This test checks whether the `getUsernameFromToken` method correctly handles JWT tokens with invalid signatures.

Execution:
Arrange: Create a JWT token with an invalid signature.

Act: Invoke the `getUsernameFromToken` method with the invalid JWT token.

Assert: Use JUnit assertions to check if the method throws an appropriate exception or the expected behavior when handling tokens with invalid signatures.

Validation:
The assertion aims to verify that the method handles tokens with invalid signatures as expected, ensuring proper security measures.

1. Scenario [4]: Verify JWT token without a subject claim

TestName: testTokenWithoutSubjectClaim()

Details:
This test checks whether the `getUsernameFromToken` method correctly handles JWT tokens without a subject claim.

Execution:
Arrange: Create a JWT token without a subject claim.

Act: Invoke the `getUsernameFromToken` method with the JWT token without a subject claim.

Assert: Use JUnit assertions to check if the method throws an appropriate exception, or the expected behavior when handling tokens without a subject claim.

Validation:
The assertion aims to verify that the method handles tokens without a subject claim as expected, ensuring proper error handling and security measures.

1. Scenario [5]: Verify JWT token with a null value

TestName: testNullToken()

Details:
This test checks whether the `getUsernameFromToken` method correctly handles null JWT tokens.

Execution:
Arrange: Set the token parameter to null.

Act: Invoke the `getUsernameFromToken` method with the null JWT token.

Assert: Use JUnit assertions to check if the method throws an appropriate exception or the expected behavior when handling null tokens.

Validation:
The assertion aims to verify that the method handles null JWT tokens as expected, ensuring proper error handling and security measures.
*/

// ********RoostGPT********
import io.jsonwebtoken.Claims;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.springframework.security.core.userdetails.UserDetails;
import java.util.Date;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class JwtTokenUtilGetUsernameFromTokenTest {

	private JwtTokenUtil jwtTokenUtil;

	@Mock
	private UserDetails userDetails;

	@BeforeEach
	public void setup() {
		MockitoAnnotations.openMocks(this);
		jwtTokenUtil = new JwtTokenUtil();
	}

	@Test
	public void testValidTokenWithSubjectClaim() {
		String expected = "testUser";
		String token = jwtTokenUtil.generateToken(userDetails, expected);
		String actual = jwtTokenUtil.getUsernameFromToken(token);
		assertEquals(expected, actual);
	}

	@Test
	public void testExpiredTokenExpirationTime() {
		Claims claims = mock(Claims.class);
		when(claims.getExpiration()).thenReturn(new Date(System.currentTimeMillis() - 10000));
		String token = jwtTokenUtil.generateToken(userDetails, claims);
		assertThrows(IllegalArgumentException.class, () -> jwtTokenUtil.getUsernameFromToken(token));
	}

	@Test
	public void testInvalidTokenSignature() {
		String token = "invalid.token.signature";
		assertThrows(IllegalArgumentException.class, () -> jwtTokenUtil.getUsernameFromToken(token));
	}

	@Test
	public void testTokenWithoutSubjectClaim() {
		Claims claims = mock(Claims.class);
		when(claims.get("sub")).thenReturn(null);
		String token = jwtTokenUtil.generateToken(userDetails, claims);
		assertThrows(IllegalArgumentException.class, () -> jwtTokenUtil.getUsernameFromToken(token));
	}

	@Test
	public void testNullToken() {
		assertThrows(IllegalArgumentException.class, () -> jwtTokenUtil.getUsernameFromToken(null));
	}

}
