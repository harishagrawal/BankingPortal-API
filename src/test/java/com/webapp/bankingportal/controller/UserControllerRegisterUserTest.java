// ********RoostGPT********
/*
Test generated by RoostGPT for test bankingportal using AI Type DBRX and AI Model mixtral-8x7b-instruct-v0.1

ROOST_METHOD_HASH=registerUser_98c668d0c6
ROOST_METHOD_SIG_HASH=registerUser_41a6a8bb96

1. Scenario 1: Register a valid user

TestName: registerValidUser
Description: This test checks if a valid user can be registered using the registerUser method.

Execution:
Arrange: Create a valid User object with all required fields filled.
Act: Invoke the registerUser method with the User object.
Assert: Verify that the ResponseEntity returned has a status of OK (200) and the UserResponse object contains the expected data.

Validation:
The test asserts that the user registration is successful and the correct data is returned in the UserResponse object. This is a crucial test to ensure that new users can sign up and register successfully.

2. Scenario 2: Register a user with missing name

TestName: registerUserMissingName
Description: This test checks if a user with a missing name can be registered.

Execution:
Arrange: Create a User object with missing name and other required fields filled.
Act: Invoke the registerUser method with the User object.
Assert: Verify that the ResponseEntity returned has a status of Bad Request (400) and contains an error message indicating that the name field cannot be empty.

Validation:
The test asserts that the registration fails with a proper error message when a required field (name) is missing. This test helps ensure that proper error handling is in place for missing mandatory fields.

3. Scenario 3: Register a user with invalid email

TestName: registerUserInvalidEmail
Description: This test checks if a user with an invalid email can be registered.

Execution:
Arrange: Create a User object with an invalid email address and other required fields filled.
Act: Invoke the registerUser method with the User object.
Assert: Verify that the ResponseEntity returned has a status of Bad Request (400) and contains an error message indicating that the email is invalid.

Validation:
The test asserts that the registration fails with a proper error message when the provided email address is invalid. This test helps ensure that the application enforces the correct email format.

4. Scenario 4: Register a user with existing email

TestName: registerUserExistingEmail
Description: This test checks if a user with an existing email can be registered.

Execution:
Arrange: Create a User object with an existing email address and other required fields filled.
Act: Invoke the registerUser method with the User object.
Assert: Verify that the ResponseEntity returned has a status of Conflict (409) and contains an error message indicating that the email is already in use.

Validation:
The test asserts that the registration fails with a proper error message when the provided email is already in use. This test helps ensure that the application prevents duplicate email addresses and maintains data integrity.

5. Scenario 5: Register a user with missing account details

TestName: registerUserMissingAccountDetails
Description: This test checks if a user with missing account details can be registered.

Execution:
Arrange: Create a User object with missing account details and other required fields filled.
Act: Invoke the registerUser method with the User object.
Assert: Verify that the ResponseEntity returned has a status of Bad Request (400) and contains an error message indicating that the account details are incomplete.

Validation:
The test asserts that the registration fails with a proper error message when account details are missing. This test helps ensure that the application enforces the correct account details format and prevents incomplete registrations.
*/

// ********RoostGPT********
import com.webapp.bankingportal.dto.UserResponse;
import com.webapp.bankingportal.entity.User;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.test.web.servlet.MockMvc;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import java.util.HashMap;
import java.util.Map;

@WebMvcTest(UserController.class)
public class UserControllerRegisterUserTest {

	@Autowired
	private MockMvc mockMvc;

	@MockBean
	private UserService userService;

	@Test
	public void registerValidUser() throws Exception {
		// Arrange
		User user = new User();
		user.setName("Test User");
		user.setEmail("test.user@example.com");
		when(userService.registerUser(user)).thenReturn(user);

		// Act & Assert
		mockMvc
			.perform(post("/api/register").contentType("application/json")
				.content("{\"name\":\"Test User\",\"email\":\"test.user@example.com\"}"))
			.andExpect(status().isOk())
			.andExpect(result -> {
				UserResponse userResponse = convertToUserResponse(result);
				assert userResponse.getName().equals("Test User");
				assert userResponse.getEmail().equals("test.user@example.com");
			});
	}

	private UserResponse convertToUserResponse(MockHttpServletResponse result) {
		Map<String, Object> responseMap = new HashMap<>();
		result.getContentAsMap(responseMap);
		UserResponse userResponse = new UserResponse();
		userResponse.setName((String) responseMap.get("name"));
		userResponse.setEmail((String) responseMap.get("email"));
		userResponse.setAccountNumber((String) responseMap.get("accountNumber"));
		userResponse.setIFSC_code((String) responseMap.get("IFSC_code"));
		userResponse.setBranch((String) responseMap.get("branch"));
		userResponse.setAccount_type((String) responseMap.get("account_type"));
		return userResponse;
	}

}
